package main

import "fmt"

// Интерфейс определяет ожидаемые клиентом методы, которые должны быть
// реализованы как классом, представляющим конкретный объект, так и классом
// нулевого объекта
type abstractEntity interface {
	doSomething()
}

// Тип конкретного объекта, реализует интерфейс и выполняет реальную бизнес-
// логику
type concreteEntity struct {
}

func (ce *concreteEntity) doSomething() {
	fmt.Println("Это конкретный объект, я выполнил какую-то реальную работу.")
}

// Тип нулевого объекта, реализует интерфейс и не выполняет бизнес-логику, а
// применяется в качестве заглушки на месте, где ожидается реальный объект
type nullEntity struct {
}

func (ne *nullEntity) doSomething() {
	fmt.Println("Это нулевой объект, я ничего не сделал, нахожусь тут просто в качестве замены конкретному объекту.")
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//------------------------------- Клиентский код -------------------------------
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

func useEntity(e abstractEntity) {
	e.doSomething()
}

func main() {
	ce := &concreteEntity{}
	ne := &nullEntity{}

	useEntity(ce)
	useEntity(ne)
}
